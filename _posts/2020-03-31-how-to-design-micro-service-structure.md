---
layout: post
title: "如何设计微服务架构"
description: ""
category: 
tags: []
---
{% include JB/setup %}
微服务架构是现在的主流架构，当准备为一个新项目确定架构，或对已有项目做微服务拆分或治理时，用什么方法划分，用什么标准来判定服务划分是否合理呢？

有大神说，通常用PND的方式，或by experience啊。

判断标准嘛，用实践判断啊，如果团队协作顺畅，效率高就是合适的。或者好用的架构就是好的架构，好用微服务拆分方式也就是好的拆分方式。

听起来很有道理的样子，但经验不多的人着手搭建或者拆分微服务时如何下手，又如何尽量避免因为拆分不合适而导致的后续落地阶段的重重困难，降低团队效率，甚至导致需要又一次微服务治理呢？毕竟一次成型的微服务结构的改动工作量可能大到惊人。

下面是最近项目上出微服务拆分方案使用的方法。适用对PND方法还没有运用到炉火纯青的小伙伴们参考。

#### 步骤1：画业务流程图

​	此流程图需要包含每一步的操作，可对照DDD中的event；和每一步操作的产出物或承载物，可对照DDD中的model或aggregate。

​	需注意的是：event粒度不能太小，不然容易丢失功能，或误以为一个大功能模块的粒度很小，从而不需要拆分，甚至会和其他模块合并。

​	如下图（为脱敏，为虚构场景）：

<div style="text-align:center"><img src ="/assets/images/faked-user-flow.png" style="height:300px;" /></div>


### 第二步：添加事件之间的依赖关系并简化为model之间的依赖关系

依赖关系考虑三个方面：

- 一个事件发生后导致另一个事件发生，包含发事件通知，或HTTP调用
- 一个事件的发生需要其他事件产生的结果中的数据
- 一个事件结果的呈现需要其他事件结果中的数据（representation）

可在上一步业务流程图上添加关系线，对业务庞大的系统可能需要根据业务流程图重新布局依赖关系图。

上述虚构场景事件间关系如下图：

<div style="text-align:center"><img src ="/assets/images/relationship-with-detail.png" style="height:300px;" /></div>

进而得出model（或每次事件的产出物）之间的关系图：

<div style="text-align:center"><img src ="/assets/images/simplified-relationship.png" style="height:300px;" /></div>

需要将细节图和简化图结合看，细节图可以看出两个model之间耦合程度，简化图可以看出model之间的集群关系。

此虚拟场景很简单，上图的作用可能没有很明显，但系统越大，这样的关系图更能清晰化业务系统错综复杂的关系。

下图为真实项目中的关系图，可一观。

<div style="text-align:center"><img src ="/assets/images/real-project-relationship-with-detail.png" style="height:300px;" /></div>
<div style="text-align:center"><img src ="/assets/images/real-project-simple-relationship.png" style="height:300px;" /></div>
### 第三步：划分上下文

根据DDD的界限上下文定义，依据上述关系图划分上下文。

**上下文定义：** 

任何大型项目都有多个模型。 然而，当基于不同模型的代码相结合，软件变得越来越多，不可靠，并且难以理解。 团队成员之间的交流变得越来越难。 模型的使用情境变得越来越不清晰。

因此：需要明确定义模型适用的上下文，并且根据团队组织，应用程序特定部分的使用情况以及代码库和数据库模式等物理表现明确设置边界。 保持模型在这些范围内严格一致，并且不被外部的问题影响。

**上下文划分原则：**

- 业务内聚，一个上下文只包含一个功能
- 需去除二义性，如两个商品在（电商的订单和快递公司的订单）不同上下文中意义不同。如果一个上下文中有包含异议的模型，则说明上下文太大，需要继续细分。
- 上下文和上下文之间最好只有一个互相影响的联系，如果联系太多，可能应该在同一上下文。

先通过对业务的理解，根据业务的内聚性做划分。

但这里就会体现仁者见仁智者见智的现象，业务是否内聚，上下文中包含的虽然是同一个功能，但是否仍然很大。

一个上下文中不存在有二义性的模型，但包含的功能太多，而且模型和模型之间联系也很松，是否应该继续细化。

这里可以先不纠结，标记下来，在后面的阶段反向修正。

### 第四步：拆分服务

根据第三步得出的上下文列表，及其之间的关系拆分微服务。这里，我们暂时将每一个上下文都设计为一个独立的微服务。

然后根据以下几个方面对初步的拆分服务方案做反向审视和修正：

#### 1. 此方案是否发挥了微服务的优点

需要注意的是，虽然需要尽量避免微服务架构的缺点，但要做好一定程度接受微服务本身缺点的准备，不能因为要完全避开微服务架构的缺点而block微服务的拆分。

优点：

- 复用性，灵活组合

- 独立性，可独立部署，升级，替换，选技术栈

- 单一职责，业务功能内聚，可维护，可扩展

- 可靠性强，服务之间分离，功能修改，互不影响

- 构建部署时间短

- 团队协作顺畅，效率高（针对大系统，不同团队协作）

缺点：

- 可能有无法避免的重复代码（模块间相似功能）

- 运维复杂，服务的升级需要保证所有使用者正常

- 影响性能

- 需要二次提交保证事务一致性。

#### 2. 是否违背的微服务的拆分原则

- 跨越了上下文？

- 跨越了组织结构？

- 不同的变更频率？

- 技术异构，不同选型？

- 对伸缩性，健壮性要求不同？

如若以上问题的答案为是，则说明需要继续拆分。

#### 3.仍然摇摆不定时，可以考虑：

- 数据库事务的需求：因为微服务架构中服务是分布式的独立的应用，再两个或者多个服务之间维护 ACID 事务就极度困难，所以微服务架构中经常会依赖 **BASE** (basic availability, soft state, and eventual consistency)。尽管如此，你还是再特定的服务中要使用 ACID （atomicity, consistency, isolation, and durability）事务。当你需要在 ACID vs. BASE 事务中做艰难的决定的时候，可能你的服务划分的就太细了。

- 服务之间的通讯，远程调用服务是需要花时间的，它会降低应用整体的性能。再者，它也会影响服务的健壮性和可靠性。如果你发现完成一个逻辑请求需要调用太多的服务时，服务的划分可能粒度就太小了。

- 在开发中的项目，还可用开发者涉及到的服务关系图判断服务间的耦合程度。Refer：#博客大赛#基于社交网络方法的系统架构分析，https://github.com/otecteng/repo-fellow

- 对已有项目整改，需要考虑拆分和合并对数据迁移，版本管理，部署改变的工作量。
- 很难有完美的方案，如果在两个方案之间摇摆不定时，列一下各个方案的痛点，按优先级排列，做个选择吧。

### 最后

微服务架构设计得是否合理好用强绑定于后续的落地。以下为实施中的反模式，以敲警钟：

- **代码重用**，这只是在开始时看起来很诱人，但后续会让重构代价高昂。

- **Everything Micro (Except for the Data)**，逻辑分离，但共用数据库。

- **数据驱动迁移反模式**（Data-Driven Migration)：服务粒度未确定就迁移数据库。应先分离功能，数据库先保持之前的单体，等到服务粒度最终确定之后，再分离数据库。

- **超时反模式**(The Timeout)：一个service timeout短了不满足要求，长了，让整个业务request时间长。解决超时反模式的方案就是使用“断路器模式”。

- **共享**反模式(I Was Taught to Share)：打破了服务之间的边界上下文，同时也引入了诸如总体可靠性、变更控制、易测试性、部署等问题。四种方式：共享项目（相对较好），共享库，冗余，服务合并。

- **可达性报告反模式** (Reach-in Reporting)：数据库拉取，HTTP拉取，batch job发异步事件推送（report专用DB）。
- **在每个服务中构建网关**，我们开始在每个服务中实现终端用户身份验证、限流、编排、转换和路由等操作。这增加了每个服务的复杂度，而且失去了服务之间实现的一致性，导致我们不知道谁在哪里实现了什么功能。

- **沙粒陷阱：** 服务粒度至关重要，它会影响应用的性能、健壮性、可靠性、可测性、设置发布模型。




